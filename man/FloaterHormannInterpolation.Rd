% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bayes_main.R
\name{FloaterHormannInterpolation}
\alias{FloaterHormannInterpolation}
\title{Floater-Hormann Rational Interpolation}
\usage{
FloaterHormannInterpolation(xvals, yvals, d)
}
\arguments{
\item{xvals}{The x values where f(x) is evaluated}

\item{yvals}{The values of f(x) at their respective xvals}

\item{d}{The degree of the polynomial. d <= N should be set to a low value 
(<=10) for a general use function and set to d \\approx N for a high 
precision evaluation}
}
\description{
Floater-Hormann interpolation, as suggested in "Barycentric rational 
interpolation with no poles and high rates of approximation Michael S. 
Floater & Kai Hormann (Equations 11 and 18)" is a method of interpolation 
that is far more stable than polynomial interpolation in equidistant or 
irregular points. While this function does benefit from points distributed 
near the end points such as Chebyshev points, it works well in almost any set
of points. It does this by moving out of the realm of polynomial functions, 
and instead, represents the function as a rational function (i.e. a 
polynomial of degree d <= N divided by another polynomial of degree f <= N). 
Using the Barycentric formula, this set of interpolates can be computed 
quickly once the weights have been computed. This function is guaranteed to 
have no poles on the real numbers, and thus wont suffer from issues with 
discontinuous functions.
}
\details{
The parameter d, the degree of the numerator and denominator, determines the 
convergence property of the interpolating rational function. The order of 
convergence is O(h^(d + 1)) if the function is smooth, and thus, for 
computational savings, select a small d (this is relative to N, the number of
points), and for very precise approximations, choose a value of d that is 
large relative to N. A caveat when choosing d is that for points distributed 
equidistant, only low values of d can be used else we will experience Runge 
phenomenon, and for points closer to Chebyshev, lower order approximations 
tend to produce inferior results. As such, when points are equidistant, keep 
the number of points <= 25 as a rule of thumb, and for points distributed 
closer to Chebyshev, take d = N for better results. d in [7,15] is a good
choice overall and generally yields good results for equidistant points

Because this function is an interpolate, it will be exactly equal to f(x) N+1
times, and thus, the precision is a function of the number of N+1 points 
primary where greater orders of approximation are honed with different values
of d. Choosing d = 3 uses third degree polynomials for the numerator and 
denominator, and thus the order of the error is O(h^4) - the same as cubic 
splines.
}
\examples{
 f <- function(x) {
   sin(x * 5) 
 }
 # Plot the function
 curve(f, -3, -1)
 
 # Set the graphical interface to a 2x1 grid
 par(mfrow = c(1,2))
 
 # Plot the {2,...,15} degree interpolants for d = N (precision oriented)
 # Do so through the equidistant points or through the chebyshev points
 # depending on which myxvals you comment out
 sapply(seq(2, 15, by = 1), function(len) {
   myxvals = seq(-3, -1,length = len)
#    myxvals = ((-cos(seq(0, len) * pi / len) + 1) / 2) * 2 - 3
   myyvals = f(myxvals)
   myfunc <- FloaterHormannInterpolation(myxvals, myyvals, d = len - 1)
   curve(f(x), -3, -1, col = "blue",  
         main = paste("Nodes:", len, "Interp. Result" ))
   abline(v = myxvals, col = "grey")
   curve(myfunc(x), -3, -1, add = T, col = "red", lty = 2)
   curve(log10(abs(myfunc(x) - f(x))), -3, -1, 
         col = "red", 
         n = 300, 
         main = paste("Error for", len, "nodes"), 
         ylim = c(-20,0))
 })
}

